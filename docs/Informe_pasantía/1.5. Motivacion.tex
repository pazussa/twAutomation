\section{Motivación: El problema de la validación en sistemas conversacionales}

La adopción acelerada de interfaces conversacionales en aplicaciones empresariales ha expuesto una paradoja fundamental en el aseguramiento de calidad del software: mientras que los sistemas tradicionales con interfaces gráficas permiten validación determinística mediante secuencias de acciones predefinidas, los agentes conversacionales introducen un espacio de estados exponencialmente mayor debido a la naturaleza no estructurada del lenguaje natural. Esta complejidad se amplifica cuando el canal de comunicación es una plataforma de mensajería de terceros como WhatsApp, donde el tester no controla ni el protocolo de comunicación ni los tiempos de respuesta del servidor.

El desafío central radica en que cada intención del usuario puede expresarse mediante decenas o cientos de variaciones lingüísticas semánticamente equivalentes. Un usuario puede solicitar información sobre cultivos diciendo "dame la lista de cultivos", "muéstrame qué cultivos tengo", "cuáles son mis cultivos registrados" o cualquiera de otras muchas formulaciones. Si consideramos que un sistema conversacional empresarial típico maneja entre veinte y cincuenta intenciones distintas, y cada una admite entre diez y cien variaciones naturales, el espacio de prueba crece hasta miles de combinaciones posibles. La estrategia tradicional de escribir casos de prueba manualmente para cada variación resulta inviable tanto por el costo temporal como por el riesgo de obsolescencia ante cambios en el modelo de procesamiento de lenguaje natural del bot.

Esta situación plantea un problema de ingeniería de particular relevancia: cómo diseñar una arquitectura de pruebas automatizadas que sea suficientemente flexible para adaptarse a la variabilidad lingüística, pero lo suficientemente robusta para detectar regresiones funcionales de manera confiable. La complejidad se multiplica cuando se considera que el bot bajo prueba no es una entidad aislada, sino que depende de múltiples servicios backend (bases de datos, APIs de terceros, motores de reglas de negocio) cuyo estado puede influir en las respuestas del agente conversacional. Una prueba exitosa no solo debe validar que el bot comprende correctamente la intención expresada en lenguaje natural, sino también que ejecuta correctamente la lógica de negocio asociada y devuelve información precisa desde las capas de persistencia.

La literatura académica sobre testing de sistemas conversacionales ha identificado tres problemas fundamentales que permanecen sin solución definitiva. El primero es el problema de la completitud: dado un conjunto finito de casos de prueba automatizados, ¿cómo garantizar que cubren adecuadamente el comportamiento esperado del sistema frente a entradas del mundo real? La naturaleza abierta del lenguaje natural hace imposible enumerar exhaustivamente todas las entradas válidas. El segundo problema es el de la detección de falsos positivos: cuando un bot devuelve una respuesta que difiere textualmente de la esperada pero es semánticamente correcta, el sistema de pruebas debe ser capaz de reconocer esta equivalencia sin requerir intervención manual. El tercer problema, especialmente crítico en aplicaciones empresariales, es la reproducibilidad: las pruebas deben ejecutarse de manera efectiva independientemente del estado previo del sistema, lo cual requiere estrategias de gestión de datos de prueba y aislamiento de contexto conversacional.

La motivación de este proyecto surge precisamente de la necesidad de abordar estos problemas mediante una arquitectura de pruebas que combine tres pilares conceptuales. El primero es la parametrización exhaustiva de datos de prueba: en lugar de codificar casos de prueba individuales, se define un modelo de datos que describe las variaciones lingüísticas permitidas para cada intención, permitiendo generar dinámicamente cientos de casos de prueba a partir de plantillas. El segundo pilar es el sistema de detección de respuestas basado en patrones con prioridades: mediante expresiones regulares ordenadas por especificidad, el framework puede reconocer múltiples formas de respuesta válida del bot sin requerir coincidencia textual exacta. El tercer pilar es el manejo de estado conversacional mediante operaciones idempotentes: cada prueba comienza limpiando el historial de conversación y termina en un estado conocido, garantizando que las ejecuciones subsecuentes no sufran interferencia por efectos residuales.

